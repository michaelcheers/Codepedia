// Source: https://cdn.jsdelivr.net/npm/node-diff3@3.0/dist/index.iife.min.js
var Diff3 = (() => { var e = Object.defineProperty, t = {}; function n(e, t) { let n = {}; for (let e = 0; e < t.length; e++) { const f = t[e]; n[f] ? n[f].push(e) : n[f] = [e] } let f = [{ buffer1index: -1, buffer2index: -1, chain: null }]; for (let t = 0; t < e.length; t++) { const r = n[e[t]] || []; let o = 0, l = f[0]; for (let e = 0; e < r.length; e++) { const n = r[e]; let u; for (u = o; u < f.length && !(f[u].buffer2index < n && (u === f.length - 1 || f[u + 1].buffer2index > n)); u++); if (u < f.length) { const e = { buffer1index: t, buffer2index: n, chain: f[u] }; if (o === f.length ? f.push(l) : f[o] = l, o = u + 1, l = e, o === f.length) break } } f[o] = l } return f[f.length - 1] } function f(e, t) { const f = n(e, t); let r = [], o = e.length, l = t.length, u = { common: [] }; function c() { u.common.length && (u.common.reverse(), r.push(u), u = { common: [] }) } for (let n = f; null !== n; n = n.chain) { let f = { buffer1: [], buffer2: [] }; for (; --o > n.buffer1index;)f.buffer1.push(e[o]); for (; --l > n.buffer2index;)f.buffer2.push(t[l]); (f.buffer1.length || f.buffer2.length) && (c(), f.buffer1.reverse(), f.buffer2.reverse(), r.push(f)), o >= 0 && u.common.push(e[o]) } return c(), r.reverse(), r } function r(e, t) { const f = n(e, t); let r = [], o = e.length, l = t.length; for (let n = f; null !== n; n = n.chain) { const f = o - n.buffer1index - 1, u = l - n.buffer2index - 1; o = n.buffer1index, l = n.buffer2index, (f || u) && r.push({ buffer1: [o + 1, f], buffer1Content: e.slice(o + 1, o + 1 + f), buffer2: [l + 1, u], buffer2Content: t.slice(l + 1, l + 1 + u) }) } return r.reverse(), r } function o(e, t) { const f = n(e, t); let r = [], o = e.length, l = t.length; function u(e, t, n) { let f = []; for (let r = 0; r < n; r++)f.push(e[t + r]); return { offset: t, length: n, chunk: f } } for (let n = f; null !== n; n = n.chain) { const f = o - n.buffer1index - 1, c = l - n.buffer2index - 1; o = n.buffer1index, l = n.buffer2index, (f || c) && r.push({ buffer1: u(e, n.buffer1index + 1, f), buffer2: u(t, n.buffer2index + 1, c) }) } return r.reverse(), r } function l(e, t, n) { let f = []; function o(e, t) { f.push({ ab: t, oStart: e.buffer1[0], oLength: e.buffer1[1], abStart: e.buffer2[0], abLength: e.buffer2[1] }) } r(t, e).forEach((e => o(e, "a"))), r(t, n).forEach((e => o(e, "b"))), f.sort(((e, t) => e.oStart - t.oStart)); let l = [], u = 0; function c(e) { e > u && (l.push({ stable: !0, buffer: "o", bufferStart: u, bufferLength: e - u, bufferContent: t.slice(u, e) }), u = e) } for (; f.length;) { let r = f.shift(), o = r.oStart, a = r.oStart + r.oLength, s = [r]; for (c(o); f.length;) { const e = f[0], t = e.oStart; if (t > a) break; a = Math.max(a, t + e.oLength), s.push(f.shift()) } if (1 === s.length) { if (r.abLength > 0) { const t = "a" === r.ab ? e : n; l.push({ stable: !0, buffer: r.ab, bufferStart: r.abStart, bufferLength: r.abLength, bufferContent: t.slice(r.abStart, r.abStart + r.abLength) }) } } else { let f = { a: [e.length, -1, t.length, -1], b: [n.length, -1, t.length, -1] }; for (; s.length;) { r = s.shift(); const e = r.oStart, t = e + r.oLength, n = r.abStart, o = n + r.abLength; let l = f[r.ab]; l[0] = Math.min(n, l[0]), l[1] = Math.max(o, l[1]), l[2] = Math.min(e, l[2]), l[3] = Math.max(t, l[3]) } const u = f.a[0] + (o - f.a[2]), c = f.a[1] + (a - f.a[3]), b = f.b[0] + (o - f.b[2]), i = f.b[1] + (a - f.b[3]); let h = { stable: !1, aStart: u, aLength: c - u, aContent: e.slice(u, c), oStart: o, oLength: a - o, oContent: t.slice(o, a), bStart: b, bLength: i - b, bContent: n.slice(b, i) }; l.push(h) } u = a } return c(t.length), l } function u(e, t, n, f) { f = Object.assign({ excludeFalseConflicts: !0, stringSeparator: /\s+/ }, f); const r = "string" == typeof t, o = "string" == typeof n; "string" == typeof e && (e = e.split(f.stringSeparator)), r && (t = t.split(f.stringSeparator)), o && (n = n.split(f.stringSeparator)); let u = []; const c = l(e, t, n); let a = []; function s() { a.length && u.push({ ok: a }), a = [] } return c.forEach((e => { e.stable ? a.push(...e.bufferContent) : f.excludeFalseConflicts && function (e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1; return !0 }(e.aContent, e.bContent) ? a.push(...e.aContent) : (s(), u.push({ conflict: { a: e.aContent, aIndex: e.aStart, o: e.oContent, oIndex: e.oStart, b: e.bContent, bIndex: e.bStart } })) })), s(), u } function c(e, t, n, f) { const r = u(e, t, n, f = Object.assign({ excludeFalseConflicts: !0, stringSeparator: /\s+/, label: {} }, f)); let o = !1, l = []; return r.forEach((e => { e.ok ? l = l.concat(e.ok) : e.conflict && (o = !0, l.push("<<<<<<<" + (f.label.a ? " " + f.label.a : "")), l = l.concat(e.conflict.a), l.push("|||||||" + (f.label.o ? " " + f.label.o : "")), l = l.concat(e.conflict.o), l.push("======="), l = l.concat(e.conflict.b), l.push(">>>>>>>" + (f.label.b ? " " + f.label.b : ""))) })), { conflict: o, result: l } } function a(e, t, n, f) { const r = u(e, t, n, f = Object.assign({ excludeFalseConflicts: !0, stringSeparator: /\s+/ }, f)); let o = !1, l = []; for (let e = 0; e < r.length; e++) { const t = r[e]; t.ok ? l = l.concat(t.ok) : (o = !0, l = l.concat(["\n<<<<<<<<<\n"], t.conflict.a, ["\n=========\n"], t.conflict.b, ["\n>>>>>>>>>\n"])) } return { conflict: o, result: l } } function s(e, t, n, r) { const o = u(e, t, n, r = Object.assign({ excludeFalseConflicts: !1, stringSeparator: /\s+/ }, r)); let l = !1, c = []; for (let e = 0; e < o.length; e++) { const t = o[e]; if (t.ok) c = c.concat(t.ok); else { const e = f(t.conflict.a, t.conflict.b); for (let t = 0; t < e.length; t++) { let n = e[t]; n.common ? c = c.concat(n.common) : (l = !0, c = c.concat(["\n<<<<<<<<<\n"], n.buffer1, ["\n=========\n"], n.buffer2, ["\n>>>>>>>>>\n"])) } } } return { conflict: l, result: c } } function b(e, t) { let n = [], f = 0; function r(t) { for (; f < t;)n.push(e[f]), f++ } for (let e = 0; e < t.length; e++) { let o = t[e]; r(o.buffer1.offset); for (let e = 0; e < o.buffer2.chunk.length; e++)n.push(o.buffer2.chunk[e]); f += o.buffer1.length } return r(e.length), n } function i(e) { return e.map((e => ({ buffer1: { offset: e.buffer1.offset, length: e.buffer1.length }, buffer2: { chunk: e.buffer2.chunk } }))) } function h(e) { return e.map((e => ({ buffer1: e.buffer2, buffer2: e.buffer1 }))) } return ((t, n) => { for (var f in (t => { e(t, "__esModule", { value: !0 }) })(t), n) e(t, f, { get: n[f], enumerable: !0 }) })(t, { LCS: () => n, diff3Merge: () => u, diff3MergeRegions: () => l, diffComm: () => f, diffIndices: () => r, diffPatch: () => o, invertPatch: () => h, merge: () => a, mergeDiff3: () => c, mergeDigIn: () => s, patch: () => b, stripPatch: () => i }), t })();

// Source: https://github.com/isomorphic-git/isomorphic-git/blob/main/src/utils/mergeFile.js
function diff3Merge({
    ourContent,
    baseContent,
    theirContent,
    ourName = 'ours',
    baseName = 'base',
    theirName = 'theirs',
    format = 'diff',
    markerSize = 7,
}) {
    const LINEBREAKS = /^.*(\r?\n|$)/gm

    const ours = ourContent.match(LINEBREAKS)
    const base = baseContent.match(LINEBREAKS)
    const theirs = theirContent.match(LINEBREAKS)

    // Here we let the diff3 library do the heavy lifting.
    const result = Diff3.diff3Merge(ours, base, theirs)

    // Here we note whether there are conflicts and format the results
    let mergedText = ''
    let cleanMerge = true
    for (const item of result) {
        if (item.ok) {
            mergedText += item.ok.join('')
        }
        if (item.conflict) {
            cleanMerge = false
            mergedText += `${'<'.repeat(markerSize)} ${ourName}\n`
            mergedText += item.conflict.a.join('')
            if (format === 'diff3') {
                mergedText += `${'|'.repeat(markerSize)} ${baseName}\n`
                mergedText += item.conflict.o.join('')
            }
            mergedText += `${'='.repeat(markerSize)}\n`
            mergedText += item.conflict.b.join('')
            mergedText += `${'>'.repeat(markerSize)} ${theirName}\n`
        }
    }
    return { cleanMerge, mergedText }
}

// Source: https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.0.0/diff.min.js
!function (e, n) { "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n((e = e || self).Diff = {}) }(this, function (e) { "use strict"; function t() { } t.prototype = { diff: function (s, u, e) { var e = 2 < arguments.length && void 0 !== e ? e : {}, n = e.callback; "function" == typeof e && (n = e, e = {}), this.options = e; var a = this; function f(e) { return n ? (setTimeout(function () { n(void 0, e) }, 0), !0) : e } s = this.castInput(s), u = this.castInput(u), s = this.removeEmpty(this.tokenize(s)); var d = (u = this.removeEmpty(this.tokenize(u))).length, c = s.length, h = 1, t = d + c, p = [{ newPos: -1, components: [] }], e = this.extractCommon(p[0], u, s, 0); if (p[0].newPos + 1 >= d && c <= e + 1) return f([{ value: this.join(u), count: u.length }]); function r() { for (var e = -1 * h; e <= h; e += 2) { var n = void 0, t = p[e - 1], r = p[e + 1], i = (r ? r.newPos : 0) - e; t && (p[e - 1] = void 0); var o = t && t.newPos + 1 < d, l = r && 0 <= i && i < c; if (o || l) { if (!o || l && t.newPos < r.newPos ? (n = { newPos: (r = r).newPos, components: r.components.slice(0) }, a.pushComponent(n.components, void 0, !0)) : ((n = t).newPos++, a.pushComponent(n.components, !0, void 0)), i = a.extractCommon(n, u, s, e), n.newPos + 1 >= d && c <= i + 1) return f(function (e, n, t, r, i) { for (var o = 0, l = n.length, s = 0, u = 0; o < l; o++) { var a, f = n[o]; f.removed ? (f.value = e.join(r.slice(u, u + f.count)), u += f.count, o && n[o - 1].added && (a = n[o - 1], n[o - 1] = n[o], n[o] = a)) : (!f.added && i ? (a = (a = t.slice(s, s + f.count)).map(function (e, n) { n = r[u + n]; return n.length > e.length ? n : e }), f.value = e.join(a)) : f.value = e.join(t.slice(s, s + f.count)), s += f.count, f.added || (u += f.count)) } var d = n[l - 1]; 1 < l && "string" == typeof d.value && (d.added || d.removed) && e.equals("", d.value) && (n[l - 2].value += d.value, n.pop()); return n }(a, n.components, u, s, a.useLongestToken)); p[e] = n } else p[e] = void 0 } h++ } if (n) !function e() { setTimeout(function () { return t < h ? n() : void (r() || e()) }, 0) }(); else for (; h <= t;) { var i = r(); if (i) return i } }, pushComponent: function (e, n, t) { var r = e[e.length - 1]; r && r.added === n && r.removed === t ? e[e.length - 1] = { count: r.count + 1, added: n, removed: t } : e.push({ count: 1, added: n, removed: t }) }, extractCommon: function (e, n, t, r) { for (var i = n.length, o = t.length, l = e.newPos, s = l - r, u = 0; l + 1 < i && s + 1 < o && this.equals(n[l + 1], t[s + 1]);)l++, s++, u++; return u && e.components.push({ count: u }), e.newPos = l, s }, equals: function (e, n) { return this.options.comparator ? this.options.comparator(e, n) : e === n || this.options.ignoreCase && e.toLowerCase() === n.toLowerCase() }, removeEmpty: function (e) { for (var n = [], t = 0; t < e.length; t++)e[t] && n.push(e[t]); return n }, castInput: function (e) { return e }, tokenize: function (e) { return e.split("") }, join: function (e) { return e.join("") } }; var r = new t; function i(e, n) { if ("function" == typeof e) n.callback = e; else if (e) for (var t in e) e.hasOwnProperty(t) && (n[t] = e[t]); return n } var o = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, l = /\S/, s = new t; s.equals = function (e, n) { return this.options.ignoreCase && (e = e.toLowerCase(), n = n.toLowerCase()), e === n || this.options.ignoreWhitespace && !l.test(e) && !l.test(n) }, s.tokenize = function (e) { for (var n = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), t = 0; t < n.length - 1; t++)!n[t + 1] && n[t + 2] && o.test(n[t]) && o.test(n[t + 2]) && (n[t] += n[t + 2], n.splice(t + 1, 2), t--); return n }; var u = new t; function m(e, n, t) { return u.diff(e, n, t) } u.tokenize = function (e) { var n = [], t = e.split(/(\n|\r\n)/); t[t.length - 1] || t.pop(); for (var r = 0; r < t.length; r++) { var i = t[r]; r % 2 && !this.options.newlineIsToken ? n[n.length - 1] += i : (this.options.ignoreWhitespace && (i = i.trim()), n.push(i)) } return n }; var a = new t; a.tokenize = function (e) { return e.split(/(\S.+?[.!?])(?=\s+|$)/) }; var f = new t; function d(e) { return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function w(e) { return function (e) { if (Array.isArray(e)) return c(e) }(e) || function (e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e) }(e) || function (e, n) { if (!e) return; if ("string" == typeof e) return c(e, n); var t = Object.prototype.toString.call(e).slice(8, -1); "Object" === t && e.constructor && (t = e.constructor.name); if ("Map" === t || "Set" === t) return Array.from(e); if ("Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return c(e, n) }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function c(e, n) { (null == n || n > e.length) && (n = e.length); for (var t = 0, r = new Array(n); t < n; t++)r[t] = e[t]; return r } f.tokenize = function (e) { return e.split(/([{}:;,]|\s+)/) }; var h = Object.prototype.toString, p = new t; function v(e, n, t, r, i) { var o, l; for (n = n || [], t = t || [], r && (e = r(i, e)), o = 0; o < n.length; o += 1)if (n[o] === e) return t[o]; if ("[object Array]" === h.call(e)) { for (n.push(e), l = new Array(e.length), t.push(l), o = 0; o < e.length; o += 1)l[o] = v(e[o], n, t, r, i); return n.pop(), t.pop(), l } if (e && e.toJSON && (e = e.toJSON()), "object" === d(e) && null !== e) { n.push(e), l = {}, t.push(l); var s, u = []; for (s in e) e.hasOwnProperty(s) && u.push(s); for (u.sort(), o = 0; o < u.length; o += 1)l[s = u[o]] = v(e[s], n, t, r, s); n.pop(), t.pop() } else l = e; return l } p.useLongestToken = !0, p.tokenize = u.tokenize, p.castInput = function (e) { var n = this.options, t = n.undefinedReplacement, n = n.stringifyReplacer, n = void 0 === n ? function (e, n) { return void 0 === n ? t : n } : n; return "string" == typeof e ? e : JSON.stringify(v(e, null, null, n), n, "  ") }, p.equals = function (e, n) { return t.prototype.equals.call(p, e.replace(/,([\r\n])/g, "$1"), n.replace(/,([\r\n])/g, "$1")) }; var g = new t; function P(e) { var l = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, s = e.split(/\r\n|[\n\v\f\r\x85]/), u = e.match(/\r\n|[\n\v\f\r\x85]/g) || [], r = [], a = 0; function n() { var e = {}; for (r.push(e); a < s.length;) { var n = s[a]; if (/^(\-\-\-|\+\+\+|@@)\s/.test(n)) break; n = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(n); n && (e.index = n[1]), a++ } for (i(e), i(e), e.hunks = []; a < s.length;) { var t = s[a]; if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(t)) break; if (/^@@/.test(t)) e.hunks.push(function () { var e = a, n = s[a++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), t = { oldStart: +n[1], oldLines: void 0 === n[2] ? 1 : +n[2], newStart: +n[3], newLines: void 0 === n[4] ? 1 : +n[4], lines: [], linedelimiters: [] }; 0 === t.oldLines && (t.oldStart += 1); 0 === t.newLines && (t.newStart += 1); for (var r = 0, i = 0; a < s.length && !(0 === s[a].indexOf("--- ") && a + 2 < s.length && 0 === s[a + 1].indexOf("+++ ") && 0 === s[a + 2].indexOf("@@")); a++) { var o = 0 == s[a].length && a != s.length - 1 ? " " : s[a][0]; if ("+" !== o && "-" !== o && " " !== o && "\\" !== o) break; t.lines.push(s[a]), t.linedelimiters.push(u[a] || "\n"), "+" === o ? r++ : "-" === o ? i++ : " " === o && (r++, i++) } r || 1 !== t.newLines || (t.newLines = 0); i || 1 !== t.oldLines || (t.oldLines = 0); if (l.strict) { if (r !== t.newLines) throw new Error("Added line count did not match for hunk at line " + (e + 1)); if (i !== t.oldLines) throw new Error("Removed line count did not match for hunk at line " + (e + 1)) } return t }()); else { if (t && l.strict) throw new Error("Unknown line " + (a + 1) + " " + JSON.stringify(t)); a++ } } } function i(e) { var n, t, r = /^(---|\+\+\+)\s+(.*)$/.exec(s[a]); r && (n = "---" === r[1] ? "old" : "new", r = (t = r[2].split("\t", 2))[0].replace(/\\\\/g, "\\"), /^".*"$/.test(r) && (r = r.substr(1, r.length - 2)), e[n + "FileName"] = r, e[n + "Header"] = (t[1] || "").trim(), a++) } for (; a < s.length;)n(); return r } function y(e, n) { var t = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}; if ("string" == typeof n && (n = P(n)), Array.isArray(n)) { if (1 < n.length) throw new Error("applyPatch only works with a single input."); n = n[0] } var r, i, o = e.split(/\r\n|[\n\v\f\r\x85]/), l = e.match(/\r\n|[\n\v\f\r\x85]/g) || [], s = n.hunks, u = t.compareLine || function (e, n, t, r) { return n === r }, a = 0, f = t.fuzzFactor || 0, d = 0, c = 0; for (var h = 0; h < s.length; h++) { for (var p = s[h], v = o.length - p.oldLines, g = 0, m = c + p.oldStart - 1, w = function (n, t, r) { var i = !0, o = !1, l = !1, s = 1; return function e() { if (i && !l) { if (o ? s++ : i = !1, n + s <= r) return s; l = !0 } if (!o) return l || (i = !0), t <= n - s ? -s++ : (o = !0, e()) } }(m, d, v); void 0 !== g; g = w())if (function (e, n) { for (var t = 0; t < e.lines.length; t++) { var r = e.lines[t], i = 0 < r.length ? r[0] : " ", r = 0 < r.length ? r.substr(1) : r; if (" " === i || "-" === i) { if (!u(n + 1, o[n], i, r) && f < ++a) return; n++ } } return 1 }(p, m + g)) { p.offset = c += g; break } if (void 0 === g) return !1; d = p.offset + p.oldStart + p.oldLines } for (var y = 0, L = 0; L < s.length; L++) { var x = s[L], S = x.oldStart + x.offset + y - 1; y += x.newLines - x.oldLines; for (var k = 0; k < x.lines.length; k++) { var b = x.lines[k], F = 0 < b.length ? b[0] : " ", N = 0 < b.length ? b.substr(1) : b, b = x.linedelimiters[k]; " " === F ? S++ : "-" === F ? (o.splice(S, 1), l.splice(S, 1)) : "+" === F ? (o.splice(S, 0, N), l.splice(S, 0, b), S++) : "\\" === F && ("+" === (F = x.lines[k - 1] ? x.lines[k - 1][0] : null) ? r = !0 : "-" === F && (i = !0)) } } if (r) for (; !o[o.length - 1];)o.pop(), l.pop(); else i && (o.push(""), l.push("\n")); for (var H = 0; H < o.length - 1; H++)o[H] = o[H] + l[H]; return o.join("") } function L(e, n, l, s, t, r, u) { void 0 === (u = u || {}).context && (u.context = 4); var a = m(l, s, u); function f(e) { return e.map(function (e) { return " " + e }) } a.push({ value: "", lines: [] }); for (var d = [], c = 0, h = 0, p = [], v = 1, g = 1, i = 0; i < a.length; i++)!function (e) { var n, t, r, i = a[e], o = i.lines || i.value.replace(/\n$/, "").split("\n"); i.lines = o, i.added || i.removed ? (c || (t = a[e - 1], c = v, h = g, t && (p = 0 < u.context ? f(t.lines.slice(-u.context)) : [], c -= p.length, h -= p.length)), p.push.apply(p, w(o.map(function (e) { return (i.added ? "+" : "-") + e }))), i.added ? g += o.length : v += o.length) : (c && (o.length <= 2 * u.context && e < a.length - 2 ? p.push.apply(p, w(f(o))) : (r = Math.min(o.length, u.context), p.push.apply(p, w(f(o.slice(0, r)))), n = { oldStart: c, oldLines: v - c + r, newStart: h, newLines: g - h + r, lines: p }, e >= a.length - 2 && o.length <= u.context && (t = /\n$/.test(l), r = /\n$/.test(s), e = 0 == o.length && p.length > n.oldLines, !t && e && 0 < l.length && p.splice(n.oldLines, 0, "\\ No newline at end of file"), (t || e) && r || p.push("\\ No newline at end of file")), d.push(n), h = c = 0, p = [])), v += o.length, g += o.length) }(i); return { oldFileName: e, newFileName: n, oldHeader: t, newHeader: r, hunks: d } } function x(e, n, t, r, i, o, l) { return function (e) { var n = []; e.oldFileName == e.newFileName && n.push("Index: " + e.oldFileName), n.push("==================================================================="), n.push("--- " + e.oldFileName + (void 0 === e.oldHeader ? "" : "\t" + e.oldHeader)), n.push("+++ " + e.newFileName + (void 0 === e.newHeader ? "" : "\t" + e.newHeader)); for (var t = 0; t < e.hunks.length; t++) { var r = e.hunks[t]; 0 === r.oldLines && --r.oldStart, 0 === r.newLines && --r.newStart, n.push("@@ -" + r.oldStart + "," + r.oldLines + " +" + r.newStart + "," + r.newLines + " @@"), n.push.apply(n, r.lines) } return n.join("\n") + "\n" }(L(e, n, t, r, i, o, l)) } function S(e, n) { if (n.length > e.length) return !1; for (var t = 0; t < n.length; t++)if (n[t] !== e[t]) return !1; return !0 } function k(e) { var n = function r(e) { var i = 0; var o = 0; e.forEach(function (e) { var n, t; "string" != typeof e ? (n = r(e.mine), t = r(e.theirs), void 0 !== i && (n.oldLines === t.oldLines ? i += n.oldLines : i = void 0), void 0 !== o && (n.newLines === t.newLines ? o += n.newLines : o = void 0)) : (void 0 === o || "+" !== e[0] && " " !== e[0] || o++, void 0 === i || "-" !== e[0] && " " !== e[0] || i++) }); return { oldLines: i, newLines: o } }(e.lines), t = n.oldLines, n = n.newLines; void 0 !== t ? e.oldLines = t : delete e.oldLines, void 0 !== n ? e.newLines = n : delete e.newLines } function b(e, n) { if ("string" != typeof e) return e; if (/^@@/m.test(e) || /^Index:/m.test(e)) return P(e)[0]; if (!n) throw new Error("Must provide a base reference or pass in a patch"); return L(void 0, void 0, n, e) } function F(e) { return e.newFileName && e.newFileName !== e.oldFileName } function N(e, n, t) { return n === t ? n : (e.conflict = !0, { mine: n, theirs: t }) } function H(e, n) { return e.oldStart < n.oldStart && e.oldStart + e.oldLines < n.oldStart } function C(e, n) { return { oldStart: e.oldStart, oldLines: e.oldLines, newStart: e.newStart + n, newLines: e.newLines, lines: e.lines } } function j(e, n, t, r) { var i = O(n), n = function (e, n) { var t = [], r = [], i = 0, o = !1, l = !1; for (; i < n.length && e.index < e.lines.length;) { var s = e.lines[e.index], u = n[i]; if ("+" === u[0]) break; if (o = o || " " !== s[0], r.push(u), i++, "+" === s[0]) for (l = !0; "+" === s[0];)t.push(s), s = e.lines[++e.index]; u.substr(1) === s.substr(1) ? (t.push(s), e.index++) : l = !0 } "+" === (n[i] || "")[0] && o && (l = !0); if (l) return t; for (; i < n.length;)r.push(n[i++]); return { merged: r, changes: t } }(t, i); n.merged ? (t = e.lines).push.apply(t, w(n.merged)) : z(e, r ? n : i, r ? i : n) } function z(e, n, t) { e.conflict = !0, e.lines.push({ conflict: !0, mine: n, theirs: t }) } function A(e, n, t) { for (; n.offset < t.offset && n.index < n.lines.length;) { var r = n.lines[n.index++]; e.lines.push(r), n.offset++ } } function E(e, n) { for (; n.index < n.lines.length;) { var t = n.lines[n.index++]; e.lines.push(t) } } function O(e) { for (var n = [], t = e.lines[e.index][0]; e.index < e.lines.length;) { var r = e.lines[e.index]; if ("-" === t && "+" === r[0] && (t = "+"), t !== r[0]) break; n.push(r), e.index++ } return n } function I(e) { return e.reduce(function (e, n) { return e && "-" === n[0] }, !0) } function $(e, n, t) { for (var r = 0; r < t; r++) { var i = n[n.length - t + r].substr(1); if (e.lines[e.index + r] !== " " + i) return } return e.index += t, 1 } g.tokenize = function (e) { return e.slice() }, g.join = g.removeEmpty = function (e) { return e }, e.Diff = t, e.applyPatch = y, e.applyPatches = function (e, i) { "string" == typeof e && (e = P(e)); var n = 0; !function t() { var r = e[n++]; if (!r) return i.complete(); i.loadFile(r, function (e, n) { return e ? i.complete(e) : (n = y(n, r, i), void i.patched(r, n, function (e) { return e ? i.complete(e) : void t() })) }) }() }, e.canonicalize = v, e.convertChangesToDMP = function (e) { for (var n, t, r = [], i = 0; i < e.length; i++)t = (n = e[i]).added ? 1 : n.removed ? -1 : 0, r.push([t, n.value]); return r }, e.convertChangesToXML = function (e) { for (var n = [], t = 0; t < e.length; t++) { var r = e[t]; r.added ? n.push("<ins>") : r.removed && n.push("<del>"), n.push(r.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")), r.added ? n.push("</ins>") : r.removed && n.push("</del>") } return n.join("") }, e.createPatch = function (e, n, t, r, i, o) { return x(e, e, n, t, r, i, o) }, e.createTwoFilesPatch = x, e.diffArrays = function (e, n, t) { return g.diff(e, n, t) }, e.diffChars = function (e, n, t) { return r.diff(e, n, t) }, e.diffCss = function (e, n, t) { return f.diff(e, n, t) }, e.diffJson = function (e, n, t) { return p.diff(e, n, t) }, e.diffLines = m, e.diffSentences = function (e, n, t) { return a.diff(e, n, t) }, e.diffTrimmedLines = function (e, n, t) { return t = i(t, { ignoreWhitespace: !0 }), u.diff(e, n, t) }, e.diffWords = function (e, n, t) { return t = i(t, { ignoreWhitespace: !0 }), s.diff(e, n, t) }, e.diffWordsWithSpace = function (e, n, t) { return s.diff(e, n, t) }, e.merge = function (e, n, t) { e = b(e, t), n = b(n, t); var r = {}; (e.index || n.index) && (r.index = e.index || n.index), (e.newFileName || n.newFileName) && (F(e) ? F(n) ? (r.oldFileName = N(r, e.oldFileName, n.oldFileName), r.newFileName = N(r, e.newFileName, n.newFileName), r.oldHeader = N(r, e.oldHeader, n.oldHeader), r.newHeader = N(r, e.newHeader, n.newHeader)) : (r.oldFileName = e.oldFileName, r.newFileName = e.newFileName, r.oldHeader = e.oldHeader, r.newHeader = e.newHeader) : (r.oldFileName = n.oldFileName || e.oldFileName, r.newFileName = n.newFileName || e.newFileName, r.oldHeader = n.oldHeader || e.oldHeader, r.newHeader = n.newHeader || e.newHeader)), r.hunks = []; for (var i = 0, o = 0, l = 0, s = 0; i < e.hunks.length || o < n.hunks.length;) { var u, a = e.hunks[i] || { oldStart: 1 / 0 }, f = n.hunks[o] || { oldStart: 1 / 0 }; H(a, f) ? (r.hunks.push(C(a, l)), i++, s += a.newLines - a.oldLines) : H(f, a) ? (r.hunks.push(C(f, s)), o++, l += f.newLines - f.oldLines) : (function (e, n, t, r, i) { var o, l = { offset: n, lines: t, index: 0 }, s = { offset: r, lines: i, index: 0 }; A(e, l, s), A(e, s, l); for (; l.index < l.lines.length && s.index < s.lines.length;) { var u = l.lines[l.index], a = s.lines[s.index]; "-" !== u[0] && "+" !== u[0] || "-" !== a[0] && "+" !== a[0] ? "+" === u[0] && " " === a[0] ? (o = e.lines).push.apply(o, w(O(l))) : "+" === a[0] && " " === u[0] ? (o = e.lines).push.apply(o, w(O(s))) : "-" === u[0] && " " === a[0] ? j(e, l, s) : "-" === a[0] && " " === u[0] ? j(e, s, l, !0) : u === a ? (e.lines.push(u), l.index++, s.index++) : z(e, O(l), O(s)) : function (e, n, t) { var r, i = O(n), o = O(t); if (I(i) && I(o)) { if (S(i, o) && $(t, i, i.length - o.length)) return (t = e.lines).push.apply(t, w(i)); if (S(o, i) && $(n, o, o.length - i.length)) return (r = e.lines).push.apply(r, w(o)) } else if (function (e, n) { return e.length === n.length && S(e, n) }(i, o)) return (r = e.lines).push.apply(r, w(i)); z(e, i, o) }(e, l, s) } E(e, l), E(e, s), k(e) }(u = { oldStart: Math.min(a.oldStart, f.oldStart), oldLines: 0, newStart: Math.min(a.newStart + l, f.oldStart + s), newLines: 0, lines: [] }, a.oldStart, a.lines, f.oldStart, f.lines), o++, i++, r.hunks.push(u)) } return r }, e.parsePatch = P, e.structuredPatch = L, Object.defineProperty(e, "__esModule", { value: !0 }) });